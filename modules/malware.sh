#!/bin/bash
# malware.sh - Malware Detection Module
# Dynamic discovery and mitigation of potential backdoors, web shells, and persistence

MODULE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$MODULE_DIR/../lib/utils.sh"
source "$MODULE_DIR/../lib/openrouter.sh"

if [[ -f "$MODULE_DIR/readme_parser.sh" ]]; then
    # shellcheck source=modules/readme_parser.sh
    source "$MODULE_DIR/readme_parser.sh"
fi

BACKUP_DIR="${BACKUP_DIR:-/var/backups/cyberpatriot}"

# Module metadata
# Module: Malware
# Category: Malware
# Description: Detects and mitigates malware, backdoors, and persistence mechanisms

readonly MALWARE_SCAN_DIRS=(
    /tmp
    /var/tmp
    /dev/shm
    /usr/local/bin
    /usr/local/sbin
    /usr/share
    /opt
    /root
)

readonly MALWARE_FILE_PATTERNS=("*.py" "*.pl" "*.sh" "*.php" "*.rb" "*.service")
readonly SUSPICIOUS_CONTENT_REGEX='(/dev/tcp/|bash\s+-i\s+>&\s+/dev/tcp/|nc\s+.*\s+-e|socat\s+.*TCP|wget\s+[^ ]+://|curl\s+[^ ]+://|pty\.spawn|base64\.(b64decode|decode)|chmod\s+\+s|chattr\s+\+i|python3?\s+-c|perl\s+-e|php\s+-r|import\s+paramiko|SimpleHTTPServer|http\.server)'
readonly PERSISTENCE_REGEX='(/tmp|/var/tmp|/dev/shm|nc\s|wget\s|curl\s|python|perl|ruby|php|bash\s+-c|socat|/dev/tcp/|\.py\b|\.pl\b)'

readonly DEFAULT_ALLOWED_LISTENERS=(
    sshd systemd-resolved systemd-networkd NetworkManager dnsmasq avahi-daemon chronyd
    cupsd cups-browsed polkitd dbus-daemon containerd dockerd snapd apache2 nginx lighttpd
    mysql mariadbd postgres vsftpd proftpd pure-ftpd
)

readonly MALWARE_AI_SYSTEM_PROMPT='You are a CyberPatriot malware analyst helping a defensive team.\n\nYou will receive JSON describing suspicious files, processes, and persistence artifacts discovered on a Linux host alongside the README critical services list and excerpt. Findings may include process artifacts that contain the executable or script path.\n\nReturn ONLY valid JSON in this exact format:\n{\n  "remove_files": [\n    {"path": "/full/path/to/file", "reason": "Brief reason (e.g., Python reverse shell listener)"}\n  ],\n  "remove_suid": [\n    {"path": "/full/path/to/suid/binary", "reason": "Brief reason (e.g., SUID on bash binary)"}\n  ],\n  "kill_processes": [\n    {"pid": "12345", "reason": "Brief reason (e.g., Suspicious netcat listener)"}\n  ],\n  "investigate_further": ["Items that require manual analyst review"],\n  "notes": ["Contextual guidance or follow-up steps"]\n}\n\nPrioritize flagging clear backdoors, reverse shells, and malicious listeners for removal. Flag SUID bits on dangerous binaries like bash, find, python. Flag suspicious processes for termination, and when a malicious process references a script or binary, also include that absolute path in remove_files so the file itself is deleted. Always warn if an action could disrupt README-designated critical services. Provide absolute file paths extracted from the findings artifacts.'

# Storage for detected artifacts
declare -a README_CRITICAL_SERVICES=()
declare -a SUSPICIOUS_FINDINGS_JSON=()
declare -a SUSPICIOUS_PROCESSES=()
declare -a SUSPICIOUS_LISTENERS=()
declare -a SUSPICIOUS_FILES=()
declare -a PERSISTENCE_FINDINGS=()
declare -a SUID_FINDINGS=()
declare -a REMEDIATIONS_APPLIED=()

load_readme_context() {
    local data_path="$MODULE_DIR/../data/readme_parsed.json"

    if declare -p README_PARSED &>/dev/null && [[ ${README_PARSED:-0} -eq 1 ]]; then
        mapfile -t README_CRITICAL_SERVICES < <(get_critical_services 2>/dev/null | grep -v '^$' || true)
    elif [[ -f "$data_path" ]] && command_exists jq; then
        mapfile -t README_CRITICAL_SERVICES < <(jq -r '.critical_services[]?' "$data_path" 2>/dev/null | grep -v '^$' || true)
    fi

    if [[ ${#README_CRITICAL_SERVICES[@]} -gt 0 ]]; then
        log_info "Loaded ${#README_CRITICAL_SERVICES[@]} critical services from README"
    else
        log_warn "No critical services found in README context"
    fi
}

is_service_marked_critical() {
    local svc="${1,,}"
    for entry in "${README_CRITICAL_SERVICES[@]}"; do
        [[ -z "$entry" ]] && continue
        local normalized="${entry,,}"
        if [[ "$svc" == "$normalized" ]]; then
            return 0
        fi
        case "$svc" in
            ssh|sshd) [[ "$normalized" =~ ssh ]] && return 0 ;;
            apache2|httpd) [[ "$normalized" =~ apache|httpd ]] && return 0 ;;
            nginx) [[ "$normalized" =~ nginx ]] && return 0 ;;
        esac
    done
    return 1
}

record_finding() {
    local type="$1"
    local message="$2"
    local severity="${3:-medium}"
    local artifact="${4:-}"

    case "$type" in
        process) SUSPICIOUS_PROCESSES+=("$message") ;;
        listener) SUSPICIOUS_LISTENERS+=("$message") ;;
        file) SUSPICIOUS_FILES+=("$message") ;;
        persistence) PERSISTENCE_FINDINGS+=("$message") ;;
        suid) SUID_FINDINGS+=("$message") ;;
        remediation) REMEDIATIONS_APPLIED+=("$message") ;;
    esac

    if [[ "$type" == "remediation" ]]; then
        log_success "[REMEDIATION] $message"
    else
        log_warn "[${type^^}][$severity] $message"
    fi

    if command_exists jq; then
        local json
        json=$(jq -n \
            --arg type "$type" \
            --arg message "$message" \
            --arg severity "$severity" \
            --arg artifact "$artifact" \
            '{type:$type, message:$message, severity:$severity, artifact:$artifact}')
        SUSPICIOUS_FINDINGS_JSON+=("$json")
    else
        SUSPICIOUS_FINDINGS_JSON+=("{\"type\":\"$type\",\"message\":\"$message\",\"severity\":\"$severity\",\"artifact\":\"$artifact\"}")
    fi
}

resolve_executable_path() {
    local pid="$1"

    if [[ -L "/proc/$pid/exe" ]]; then
        readlink -f "/proc/$pid/exe" 2>/dev/null || true
    fi
}

extract_command_path() {
    local cmd="$1"
    local token

    for token in $cmd; do
        token="${token%\"}"
        token="${token#\"}"
        token="${token%\'}"
        token="${token#\'}"

        if [[ "$token" == */* ]] && [[ -f "$token" ]]; then
            echo "$token"
            return 0
        fi
    done
}

generate_findings_json() {
    if [[ ${#SUSPICIOUS_FINDINGS_JSON[@]} -eq 0 ]]; then
        echo "[]"
        return 0
    fi

    printf '[\n'
    local i
    for i in "${!SUSPICIOUS_FINDINGS_JSON[@]}"; do
        (( i > 0 )) && printf ',\n'
        printf '%s' "${SUSPICIOUS_FINDINGS_JSON[$i]}"
    done
    printf '\n]\n'
}

quarantine_file() {
    local file="$1"
    local reason="$2"

    if [[ ! -f "$file" ]]; then
        return 0
    fi

    mkdir -p "$BACKUP_DIR/quarantine"
    local base=$(basename "$file")
    local ts=$(date +%Y%m%d_%H%M%S)
    local dest="$BACKUP_DIR/quarantine/${base}.${ts}.quarantined"

    if mv "$file" "$dest" 2>/dev/null; then
        record_finding "remediation" "Quarantined $file (reason: $reason)" "high" "$dest"
    else
        log_warn "Failed to quarantine $file"
    fi
}

check_optional_security_tooling() {
    if command_exists clamscan; then
        log_info "ClamAV (clamscan) is installed"
    else
        log_warn "ClamAV not installed (install with: sudo apt-get install clamav)"
    fi

    if command_exists rkhunter; then
        log_info "rkhunter is installed"
    else
        log_warn "rkhunter not installed (install with: sudo apt-get install rkhunter)"
    fi
}
scan_suspicious_processes() {
    log_section "Process Analysis"
    local regex='(/dev/tcp/|bash[[:space:]]+-i[[:space:]]+>&[[:space:]]+/dev/tcp/|nc[[:space:]].*(-e|-c)|socat[[:space:]].*TCP|python[0-9.]*[[:space:]].*-c[[:space:]].*(socket|base64)|perl[[:space:]].*-e[[:space:]].*(socket|system)|php[[:space:]].*-r[[:space:]].*(system|shell_exec)|openssl[[:space:]].*-connect[[:space:]].*sh)'

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        line="${line## }"
        local pid user cmd
        pid=${line%% *}
        local remaining="${line#* }"
        remaining="${remaining## }"
        user=${remaining%% *}
        cmd=${remaining#* }
        cmd="${cmd## }"

        if [[ "$cmd" =~ $regex ]] || [[ "$cmd" == */tmp/* ]] || [[ "$cmd" == */var/tmp/* ]]; then
            local exe_path
            exe_path=$(resolve_executable_path "$pid")

            local script_path
            script_path=$(extract_command_path "$cmd")

            local description="PID $pid ($user) running suspicious command: $cmd"
            if [[ -n "$exe_path" ]]; then
                description+=" [exe: $exe_path]"
            fi
            if [[ -n "$script_path" && "$script_path" != "$exe_path" ]]; then
                description+=" [script: $script_path]"
            fi

            local artifact="${script_path:-${exe_path:-$pid}}"
            record_finding "process" "$description" "high" "$artifact"
        fi
    done < <(ps axww -o pid=,user=,command=)
}

scan_network_listeners() {
    log_section "Network Listener Analysis"

    if ! command_exists ss; then
        log_warn "ss command not available; skipping listener analysis"
        return
    fi

    local allowlist=("${DEFAULT_ALLOWED_LISTENERS[@]}")
    if [[ ${#README_CRITICAL_SERVICES[@]} -gt 0 ]]; then
        allowlist+=("${README_CRITICAL_SERVICES[@]}")
    fi

    local listener_output
    listener_output=$(ss -tulpen 2>/dev/null)
    if [[ -z "$listener_output" ]]; then
        log_info "No listening sockets detected"
        return
    fi

    log_debug "Active listeners:\n$listener_output"

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        [[ "$line" == State* ]] && continue

        local pid
        pid=$(echo "$line" | sed -n 's/.*pid=\([0-9]\+\).*/\1/p')
        local comm=""
        if [[ -n "$pid" && -r "/proc/$pid/comm" ]]; then
            comm=$(tr -d '\0' <"/proc/$pid/comm" 2>/dev/null)
        fi

        local allowed=0
        local candidate="${comm,,}"
        for item in "${allowlist[@]}"; do
            [[ -z "$item" ]] && continue
            if [[ "$candidate" == "${item,,}" ]]; then
                allowed=1
                break
            fi
        done

        if [[ $allowed -eq 0 ]]; then
            local exe_path
            exe_path=$(resolve_executable_path "$pid")

            local script_path
            script_path=$(extract_command_path "$line")

            local description="Suspicious listener: $line"
            if [[ -n "$exe_path" ]]; then
                description+=" [exe: $exe_path]"
            fi
            if [[ -n "$script_path" && "$script_path" != "$exe_path" ]]; then
                description+=" [script: $script_path]"
            fi

            local artifact="${script_path:-${exe_path:-$pid}}"
            record_finding "listener" "$description" "medium" "$artifact"
        fi
    done <<< "$listener_output"
}

sanitize_cron_file() {
    local file="$1"
    local matches="$2"

    if [[ -z "$matches" ]]; then
        return 0
    fi

    if ! command_exists python3; then
        log_warn "python3 unavailable; cannot automatically sanitize $file"
        return 1
    fi

    backup_file "$file"
    local pattern="$PERSISTENCE_REGEX"
    local result
    result=$(python3 - "$file" "$pattern" <<'PY'
import re
import sys
from pathlib import Path

path = Path(sys.argv[1])
pattern = re.compile(sys.argv[2], re.IGNORECASE)
changed = False
lines = path.read_text().splitlines()
output = []
for line in lines:
    if pattern.search(line) and not line.lstrip().startswith('# DISABLED BY CYBERPATRIOT:'):
        output.append('# DISABLED BY CYBERPATRIOT: ' + line)
        changed = True
    else:
        output.append(line)
path.write_text('\n'.join(output) + '\n')
if changed:
    print('changed')
PY
)

    if [[ "$result" == "changed" ]]; then
        record_finding "remediation" "Commented suspicious cron entries in $file" "high" "$file"
    else
        log_info "No changes applied to $file"
    fi
}

scan_persistence_mechanisms() {
    log_section "Persistence Analysis"
    local cron_files=(/etc/crontab /etc/cron.d/* /etc/cron.daily/* /etc/cron.hourly/* /etc/cron.weekly/* /var/spool/cron/crontabs/*)

    for cron in "${cron_files[@]}"; do
        [[ -f "$cron" ]] || continue
        local hits
        hits=$(grep -En "$PERSISTENCE_REGEX" "$cron" 2>/dev/null || true)
        if [[ -n "$hits" ]]; then
            record_finding "persistence" "Suspicious cron entries detected in $cron" "high" "$cron"
            sanitize_cron_file "$cron" "$hits"
        fi
    done

    local unit_dirs=(/etc/systemd/system /lib/systemd/system)
    local dir
    for dir in "${unit_dirs[@]}"; do
        [[ -d "$dir" ]] || continue
        while IFS= read -r -d '' unit; do
            local exec_line
            exec_line=$(grep -E '^ExecStart=' "$unit" 2>/dev/null | grep -Ei "$PERSISTENCE_REGEX" || true)
            [[ -z "$exec_line" ]] && continue

            local service_name=$(basename "$unit")
            service_name="${service_name%.service}"

            if ! is_service_marked_critical "$service_name"; then
                record_finding "persistence" "Disabling suspicious systemd unit $service_name ($unit)" "high" "$unit"
                systemctl disable --now "$service_name" 2>/dev/null || true
                mv "$unit" "$unit.disabled" 2>/dev/null || true
                record_finding "remediation" "Masked suspicious systemd service $service_name" "high" "$unit.disabled"
            else
                record_finding "persistence" "Suspicious ExecStart in critical service $service_name (manual review)" "medium" "$unit"
            fi
        done < <(find "$dir" -maxdepth 1 -name '*.service' -print0 2>/dev/null)
    done

    if [[ -f /etc/ld.so.preload ]]; then
        local preload_content
        preload_content=$(cat /etc/ld.so.preload 2>/dev/null)
        if [[ "$preload_content" =~ /tmp|/var/tmp|/dev/shm ]]; then
            backup_file /etc/ld.so.preload
            mv /etc/ld.so.preload /etc/ld.so.preload.cyberpatriot-disabled 2>/dev/null || true
            record_finding "remediation" "Disabled malicious ld.so.preload entry" "high" "/etc/ld.so.preload"
        else
            record_finding "persistence" "/etc/ld.so.preload exists; manual review recommended" "medium" "/etc/ld.so.preload"
        fi
    fi
}
collect_candidate_files() {
    local -n __out=$1
    __out=()

    local dir
    for dir in "${MALWARE_SCAN_DIRS[@]}"; do
        [[ -d "$dir" ]] || continue
        while IFS= read -r -d '' file; do
            # Filter by pattern or SUID bit
            local include=0
            local name=$(basename "$file")
            for pattern in "${MALWARE_FILE_PATTERNS[@]}"; do
                if [[ $name == $pattern ]]; then
                    include=1
                    break
                fi
            done
            if [[ $include -eq 0 ]]; then
                if [[ -u "$file" ]]; then
                    include=1
                fi
            fi
            if [[ $include -eq 1 ]]; then
                __out+=("$file")
            fi
        done < <(find "$dir" -xdev -type f -size -1M -print0 2>/dev/null)
    done
}

run_heuristic_scanner() {
    local -n __files=$1
    (( ${#__files[@]} )) || return 0

    if ! command_exists python3; then
        log_warn "python3 not available; skipping heuristic scan"
        return 1
    fi

    local helper
    helper=$(mktemp)
    cat <<'PY' >"$helper"
#!/usr/bin/env python3
import json
import pathlib
import re
import sys

SUSPICIOUS_PATTERNS = [
    r"/dev/tcp/",
    r"bash\s+-i\s+>&\s+/dev/tcp/",
    r"nc\s+.*\s+-e",
    r"socket\.socket",
    r"pty\.spawn",
    r"subprocess\.(Popen|call|run)",
    r"base64\.b64decode",
    r"exec\(",
    r"eval\(",
    r"SimpleHTTPServer",
    r"http\.server",
    r"wget\s+[a-z]+://",
    r"curl\s+[a-z]+://",
    r"chmod\s+\+s",
    r"chattr\s+\+i",
]

CATEGORY_PATTERNS = {
    "reverse_shell": [r"/dev/tcp/", r"bash\s+-i\s+>&\s+/dev/tcp/", r"nc\s+.*\s+-e"],
    "network": [r"socket\.socket", r"SimpleHTTPServer", r"http\.server", r"wget\s", r"curl\s"],
    "persistence": [r"chmod\s+\+s", r"chattr\s+\+i"],
    "evasion": [r"base64\.b64decode", r"exec\(", r"eval\("]
}

WEIGHTS = {
    "reverse_shell": 40,
    "network": 25,
    "persistence": 20,
    "evasion": 15,
}

results = []
for item in sys.argv[1:]:
    path = pathlib.Path(item)
    try:
        if not path.is_file():
            continue
        if path.stat().st_size > 1_000_000:
            continue
        data = path.read_text(errors='ignore')
    except Exception:
        continue

    score = 0
    tags = []
    for category, patterns in CATEGORY_PATTERNS.items():
        for pattern in patterns:
            if re.search(pattern, data, re.IGNORECASE):
                if category not in tags:
                    tags.append(category)
                    score += WEIGHTS.get(category, 10)
                break
    hits = sum(1 for pattern in SUSPICIOUS_PATTERNS if re.search(pattern, data, re.IGNORECASE))
    score += min(hits * 5, 40)
    if score >= 30:
        results.append({"file": str(path), "score": min(score, 100), "tags": tags})

print(json.dumps(results))
PY
    chmod +x "$helper"

    local json
    json=$(python3 "$helper" "${__files[@]}" 2>/dev/null)
    rm -f "$helper"

    if [[ -z "$json" ]]; then
        return 0
    fi

    if command_exists jq; then
        local count
        count=$(echo "$json" | jq 'length' 2>/dev/null)
        if [[ "$count" -gt 0 ]]; then
            log_info "Heuristic scanner flagged $count files"
            echo "$json" | jq -c '.[]' | while read -r entry; do
                local path score tags
                path=$(echo "$entry" | jq -r '.file')
                score=$(echo "$entry" | jq -r '.score')
                tags=$(echo "$entry" | jq -r '.tags | join(",")')
                record_finding "file" "Suspicious script $path (score: $score, tags: $tags)" "high" "$path"
                if (( score >= 80 )) && [[ "$path" == /tmp/* || "$path" == /var/tmp/* || "$path" == /dev/shm/* ]]; then
                    quarantine_file "$path" "High heuristic score $score"
                fi
            done
        fi
    fi
}

scan_service_specific_artifacts() {
    log_section "Service-Aware Malware Scan"

    local has_web=0
    local service
    for service in "${README_CRITICAL_SERVICES[@]}"; do
        [[ -z "$service" ]] && continue
        if [[ "${service,,}" =~ apache|nginx|httpd ]]; then
            has_web=1
        fi
    done

    if (( has_web )); then
        local web_roots=(/var/www /srv/www /var/lib/www /usr/share/nginx)
        local root
        for root in "${web_roots[@]}"; do
            [[ -d "$root" ]] || continue
            while IFS= read -r -d '' file; do
                local hit
                hit=$(grep -E "(system\(|shell_exec|passthru|eval|assert\(|base64_decode)" "$file" 2>/dev/null || true)
                if [[ -n "$hit" ]]; then
                    record_finding "file" "Potential web shell: $file" "high" "$file"
                    quarantine_file "$file" "Suspected web shell"
                fi
            done < <(find "$root" -type f \( -name '*.php' -o -name '*.jsp' -o -name '*.py' \) -print0 2>/dev/null)
        done
    fi

    if printf '%s\n' "${README_CRITICAL_SERVICES[@]}" | grep -qi 'ssh'; then
        while IFS= read -r -d '' file; do
            local hit
            hit=$(grep -E "(paramiko|pty\.spawn|/dev/tcp/|socket\.socket)" "$file" 2>/dev/null || true)
            if [[ -n "$hit" ]]; then
                record_finding "file" "SSH-adjacent suspicious script: $file" "medium" "$file"
            fi
        done < <(find /usr/share /usr/lib -maxdepth 4 -type f -name '*.py' -print0 2>/dev/null)
    fi
}

scan_filesystem() {
    log_section "Filesystem Scan"
    local -a candidates=()
    collect_candidate_files candidates

    if (( ${#candidates[@]} == 0 )); then
        log_info "No candidate files discovered for malware sweep"
        return
    fi

    local chunk_size=200
    local idx=0
    while (( idx < ${#candidates[@]} )); do
        local slice=("${candidates[@]:idx:chunk_size}")
        if command_exists grep; then
            local hits
            hits=$(grep -El "$SUSPICIOUS_CONTENT_REGEX" "${slice[@]}" 2>/dev/null || true)
            if [[ -n "$hits" ]]; then
                while IFS= read -r path; do
                    [[ -z "$path" ]] && continue
                    record_finding "file" "Signature match for suspicious content: $path" "high" "$path"
                done <<< "$hits"
            fi
        fi
        (( idx += chunk_size ))
    done

    run_heuristic_scanner candidates
}

prompt_user_approval() {
    local item_type="$1"
    local item_path="$2"
    local reason="$3"

    log_warn "┌─────────────────────────────────────────────────────────────"
    log_warn "│ REMOVAL REQUEST"
    log_warn "│ Type: $item_type"
    log_warn "│ Path/ID: $item_path"
    log_warn "│ Reason: $reason"
    log_warn "└─────────────────────────────────────────────────────────────"

    read -r -p "Remove this $item_type? [y/N] " response
    case "$response" in
        [yY][eE][sS]|[yY])
            return 0
            ;;
        *)
            log_info "Skipped removal of $item_path"
            return 1
            ;;
    esac
}

kill_process_safely() {
    local pid="$1"
    local reason="$2"

    if ! prompt_user_approval "process" "PID $pid" "$reason"; then
        return 1
    fi

    if [[ ! -d "/proc/$pid" ]]; then
        log_warn "Process $pid no longer exists"
        return 1
    fi

    local comm=""
    if [[ -r "/proc/$pid/comm" ]]; then
        comm=$(cat "/proc/$pid/comm" 2>/dev/null || echo "unknown")
    fi

    log_info "Killing process $pid ($comm)..."

    # Try SIGTERM first
    if kill -15 "$pid" 2>/dev/null; then
        sleep 1
        if [[ ! -d "/proc/$pid" ]]; then
            record_finding "remediation" "Terminated process $pid ($comm) - $reason" "high" "$pid"
            return 0
        fi
    fi

    # Force kill if still running
    if kill -9 "$pid" 2>/dev/null; then
        sleep 0.5
        if [[ ! -d "/proc/$pid" ]]; then
            record_finding "remediation" "Force-killed process $pid ($comm) - $reason" "high" "$pid"
            return 0
        fi
    fi

    log_error "Failed to kill process $pid"
    return 1
}

remove_suid_bit() {
    local file="$1"
    local reason="$2"

    if [[ ! -f "$file" ]]; then
        log_warn "File not found: $file"
        return 1
    fi

    if ! prompt_user_approval "SUID bit" "$file" "$reason"; then
        return 1
    fi

    log_info "Removing SUID bit from $file..."

    if chmod u-s "$file" 2>/dev/null; then
        record_finding "remediation" "Removed SUID bit from $file - $reason" "high" "$file"
        return 0
    else
        log_error "Failed to remove SUID bit from $file"
        return 1
    fi
}

remove_file_safely() {
    local file="$1"
    local reason="$2"

    if [[ ! -e "$file" ]]; then
        log_warn "File not found: $file"
        return 1
    fi

    if ! prompt_user_approval "file" "$file" "$reason"; then
        return 1
    fi

    log_info "Removing file $file..."

    # Check for processes using this file
    if command_exists lsof; then
        local pids
        pids=$(lsof -t "$file" 2>/dev/null || true)
        if [[ -n "$pids" ]]; then
            log_warn "Processes using $file: $pids"
            for pid in $pids; do
                local comm=""
                if [[ -r "/proc/$pid/comm" ]]; then
                    comm=$(cat "/proc/$pid/comm" 2>/dev/null || echo "unknown")
                fi
                log_warn "  PID $pid ($comm)"
                read -r -p "Kill process $pid ($comm) to release file? [y/N] " response
                case "$response" in
                    [yY][eE][sS]|[yY])
                        kill -9 "$pid" 2>/dev/null || true
                        sleep 0.5
                        ;;
                esac
            done
        fi
    fi

    # Remove immutable flag if present
    if command_exists lsattr && lsattr "$file" 2>/dev/null | grep -q '\-i\-'; then
        log_info "Removing immutable flag from $file..."
        if ! chattr -i "$file" 2>/dev/null; then
            log_warn "Failed to remove immutable flag, trying anyway..."
        fi
    fi

    # Backup before removal
    backup_file "$file" 2>/dev/null || true

    # Remove the file
    if rm -f "$file" 2>/dev/null; then
        record_finding "remediation" "Removed malicious file $file - $reason" "high" "$file"
        return 0
    else
        log_error "Failed to remove $file"
        return 1
    fi
}

scan_suid_anomalies() {
    log_section "SUID Audit"
    while IFS= read -r -d '' file; do
        local base=$(basename "$file")
        case "$file" in
            /usr/bin/sudo|/usr/bin/passwd|/usr/bin/chsh|/usr/bin/chfn|/usr/bin/gpasswd|/usr/bin/newgrp|/usr/lib/openssh/ssh-keysign|/usr/lib/dbus-1.0/dbus-daemon-launch-helper)
                continue
                ;;
        esac

        record_finding "suid" "Unexpected SUID binary: $file" "medium" "$file"
        if [[ "$base" == "find" || "$base" == "bash" || "$base" == "sh" ]]; then
            chmod u-s "$file" 2>/dev/null || true
            record_finding "remediation" "Removed SUID bit from $file" "high" "$file"
        fi
    done < <(find / -xdev -perm -4000 -type f -print0 2>/dev/null)
}
analyze_findings_with_ai() {
    if [[ ${#SUSPICIOUS_FINDINGS_JSON[@]} -eq 0 ]]; then
        return 0
    fi

    if ! command_exists jq; then
        log_warn "jq not available; skipping AI malware triage"
        return 1
    fi

    if ! check_openrouter_config; then
        log_info "OpenRouter API key not configured; skipping AI malware triage"
        return 1
    fi

    local findings_json
    findings_json=$(generate_findings_json)

    local critical_joined="None specified"
    if [[ ${#README_CRITICAL_SERVICES[@]} -gt 0 ]]; then
        critical_joined=$(printf '%s,' "${README_CRITICAL_SERVICES[@]}")
        critical_joined=${critical_joined%,}
    fi

    local readme_excerpt=""
    local readme_plain="$MODULE_DIR/../data/readme_plaintext.txt"
    if [[ -f "$readme_plain" ]]; then
        readme_excerpt=$(head -n 200 "$readme_plain")
    fi

    local user_message
    user_message=$(cat <<EOF2
Malware findings JSON:
$findings_json

Critical services from README: $critical_joined

README excerpt (first 200 lines):
$readme_excerpt
EOF2
)

    local payload
    payload=$(jq -n \
        --arg model "$OPENROUTER_MODEL" \
        --arg system "$MALWARE_AI_SYSTEM_PROMPT" \
        --arg user "$user_message" \
        '{model:$model, messages:[{role:"system",content:$system},{role:"user",content:$user}], temperature:0.1, max_tokens:6500}')

    local response
    response=$(curl -s -X POST "$OPENROUTER_API_URL" \
        -H "Authorization: Bearer $OPENROUTER_API_KEY" \
        -H "Content-Type: application/json" \
        -H "HTTP-Referer: https://github.com/cyberpatriot-linux-auto" \
        -d "$payload")

    local ai_content
    ai_content=$(echo "$response" | jq -r '.choices[0].message.content' 2>/dev/null)
    if [[ -z "$ai_content" || "$ai_content" == "null" ]]; then
        local error_message
        error_message=$(echo "$response" | jq -r '.error.message // empty' 2>/dev/null)
        if [[ -n "$error_message" ]]; then
            log_error "AI malware triage error: $error_message"
        else
            log_warn "AI malware triage returned no content"
            log_debug "AI malware raw response: $response"
        fi
        return 1
    fi

    log_section "AI Malware Triage"
    local parsed_json=""
    if echo "$ai_content" | jq -e '.' >/dev/null 2>&1; then
        parsed_json="$ai_content"
    else
        local fence_stripped
        fence_stripped=$(echo "$ai_content" | sed -e '1{/^```[[:alnum:]_-]*[[:space:]]*$/d;}' -e '${/^```[[:space:]]*$/d;}')

        if [[ -n "$fence_stripped" ]] && echo "$fence_stripped" | jq -e '.' >/dev/null 2>&1; then
            parsed_json="$fence_stripped"
        else
            parsed_json=$(extract_json_from_response "$ai_content" 2>/dev/null || true)
        fi
    fi

    mkdir -p "$MODULE_DIR/../data"

    if [[ -n "$parsed_json" ]] && echo "$parsed_json" | jq -e '.' >/dev/null 2>&1; then
        log_info "AI recommendations (parsed JSON):"
        echo "$parsed_json" | jq '.'
        echo "$parsed_json" | jq '.' >"$MODULE_DIR/../data/malware_ai_recommendations.json"

        # Process AI recommendations for automated remediation
        log_section "AI-Recommended Remediation"

        # Display notes first
        local notes_count
        notes_count=$(echo "$parsed_json" | jq -r '.notes // [] | length' 2>/dev/null)
        if [[ "$notes_count" -gt 0 ]]; then
            log_info "=== NOTES ==="
            echo "$parsed_json" | jq -r '.notes[]?' 2>/dev/null | while read -r note; do
                [[ -z "$note" ]] && continue
                log_info "  • $note"
            done
            echo ""
        fi

        # Display items to investigate manually
        local investigate_count
        investigate_count=$(echo "$parsed_json" | jq -r '.investigate_further // [] | length' 2>/dev/null)
        if [[ "$investigate_count" -gt 0 ]]; then
            log_warn "=== REQUIRES MANUAL REVIEW ==="
            echo "$parsed_json" | jq -r '.investigate_further[]?' 2>/dev/null | while read -r item; do
                [[ -z "$item" ]] && continue
                log_warn "  • $item"
            done
            echo ""
        fi

        # Process file removals
        local remove_files_count
        remove_files_count=$(echo "$parsed_json" | jq -r '.remove_files // [] | length' 2>/dev/null)
        if [[ "$remove_files_count" -gt 0 ]]; then
            log_info "=== FILES FLAGGED FOR REMOVAL ==="
            echo "$parsed_json" | jq -c '.remove_files[]?' 2>/dev/null | while read -r entry; do
                local file_path reason
                file_path=$(echo "$entry" | jq -r '.path' 2>/dev/null)
                reason=$(echo "$entry" | jq -r '.reason' 2>/dev/null)

                if [[ -n "$file_path" && "$file_path" != "null" ]]; then
                    remove_file_safely "$file_path" "$reason" || true
                fi
            done
            echo ""
        fi

        # Process SUID removals
        local remove_suid_count
        remove_suid_count=$(echo "$parsed_json" | jq -r '.remove_suid // [] | length' 2>/dev/null)
        if [[ "$remove_suid_count" -gt 0 ]]; then
            log_info "=== SUID BITS FLAGGED FOR REMOVAL ==="
            echo "$parsed_json" | jq -c '.remove_suid[]?' 2>/dev/null | while read -r entry; do
                local file_path reason
                file_path=$(echo "$entry" | jq -r '.path' 2>/dev/null)
                reason=$(echo "$entry" | jq -r '.reason' 2>/dev/null)

                if [[ -n "$file_path" && "$file_path" != "null" ]]; then
                    remove_suid_bit "$file_path" "$reason" || true
                fi
            done
            echo ""
        fi

        # Process process kills
        local kill_processes_count
        kill_processes_count=$(echo "$parsed_json" | jq -r '.kill_processes // [] | length' 2>/dev/null)
        if [[ "$kill_processes_count" -gt 0 ]]; then
            log_info "=== PROCESSES FLAGGED FOR TERMINATION ==="
            echo "$parsed_json" | jq -c '.kill_processes[]?' 2>/dev/null | while read -r entry; do
                local pid reason
                pid=$(echo "$entry" | jq -r '.pid' 2>/dev/null)
                reason=$(echo "$entry" | jq -r '.reason' 2>/dev/null)

                if [[ -n "$pid" && "$pid" != "null" ]]; then
                    kill_process_safely "$pid" "$reason" || true
                fi
            done
            echo ""
        fi
    else
        log_info "AI recommendations: $ai_content"
        printf '%s\n' "$ai_content" >"$MODULE_DIR/../data/malware_ai_recommendations.json"
    fi
}

summarize_findings() {
    log_section "Malware Findings Summary"

    log_info "Suspicious processes detected: ${#SUSPICIOUS_PROCESSES[@]}"
    if [[ ${#SUSPICIOUS_PROCESSES[@]} -gt 0 ]]; then
        for entry in "${SUSPICIOUS_PROCESSES[@]}"; do
            log_warn "  - $entry"
        done
    fi

    log_info "Suspicious listeners detected: ${#SUSPICIOUS_LISTENERS[@]}"
    if [[ ${#SUSPICIOUS_LISTENERS[@]} -gt 0 ]]; then
        for entry in "${SUSPICIOUS_LISTENERS[@]}"; do
            log_warn "  - $entry"
        done
    fi

    log_info "Suspicious files detected: ${#SUSPICIOUS_FILES[@]}"
    if [[ ${#SUSPICIOUS_FILES[@]} -gt 0 ]]; then
        for entry in "${SUSPICIOUS_FILES[@]}"; do
            log_warn "  - $entry"
        done
    fi

    log_info "Persistence findings: ${#PERSISTENCE_FINDINGS[@]}"
    if [[ ${#PERSISTENCE_FINDINGS[@]} -gt 0 ]]; then
        for entry in "${PERSISTENCE_FINDINGS[@]}"; do
            log_warn "  - $entry"
        done
    fi

    log_info "SUID anomalies: ${#SUID_FINDINGS[@]}"
    if [[ ${#SUID_FINDINGS[@]} -gt 0 ]]; then
        for entry in "${SUID_FINDINGS[@]}"; do
            log_warn "  - $entry"
        done
    fi

    log_info "Remediations applied: ${#REMEDIATIONS_APPLIED[@]}"
    if [[ ${#REMEDIATIONS_APPLIED[@]} -gt 0 ]]; then
        for entry in "${REMEDIATIONS_APPLIED[@]}"; do
            log_success "  - $entry"
        done
    fi
}

run_malware() {
    log_info "Starting Malware Detection module..."

    require_root
    load_readme_context
    check_optional_security_tooling

    scan_suspicious_processes
    scan_network_listeners
    scan_persistence_mechanisms
    scan_service_specific_artifacts
    scan_filesystem
    scan_suid_anomalies

    summarize_findings
    analyze_findings_with_ai

    return 0
}

export -f run_malware
