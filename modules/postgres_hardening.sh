#!/bin/bash
# postgres_hardening.sh - PostgreSQL Hardening Module
# Implements comprehensive PostgreSQL security hardening for CyberPatriot competitions

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../lib/utils.sh"

# Module: PostgreSQL Hardening
# Category: Database Security
# Description: Hardens PostgreSQL server configuration, authentication, and file permissions

# ====== EDITABLE DEFAULTS ======
readonly PG_LISTEN_ADDRESSES="${PG_LISTEN_ADDRESSES:-localhost}"
readonly PG_PORT="${PG_PORT:-5432}"
readonly PG_SUPERUSER="${PG_SUPERUSER:-postgres}"
readonly PG_SSL_CERT="${PG_SSL_CERT:-/etc/ssl/certs/ssl-cert-snakeoil.pem}"
readonly PG_SSL_KEY="${PG_SSL_KEY:-/etc/ssl/private/ssl-cert-snakeoil.key}"
readonly PG_AUTH_METHOD="${PG_AUTH_METHOD:-scram-sha-256}"  # or md5
readonly PG_REQUIRE_SSL_REMOTE="${PG_REQUIRE_SSL_REMOTE:-yes}"

# Detect PostgreSQL version and configuration paths
detect_postgres_version() {
    local versions=(16 15 14 13 12 11 10)

    for ver in "${versions[@]}"; do
        if [[ -d "/etc/postgresql/$ver/main" ]]; then
            echo "$ver"
            return 0
        fi
    done

    # Try to detect from postgres command
    if command_exists postgres; then
        postgres --version 2>/dev/null | grep -oP '\d+' | head -n1 || true
        return 0
    fi

    return 1
}

postgres_config_path() {
    local version="$1"
    local candidates=(
        "/etc/postgresql/${version}/main/postgresql.conf"
        "/etc/postgresql/postgresql.conf"
        "/var/lib/pgsql/${version}/data/postgresql.conf"
        "/var/lib/postgresql/${version}/main/postgresql.conf"
    )

    for file in "${candidates[@]}"; do
        [[ -f "$file" ]] && echo "$file" && return 0
    done

    return 1
}

pg_hba_config_path() {
    local version="$1"
    local candidates=(
        "/etc/postgresql/${version}/main/pg_hba.conf"
        "/etc/postgresql/pg_hba.conf"
        "/var/lib/pgsql/${version}/data/pg_hba.conf"
        "/var/lib/postgresql/${version}/main/pg_hba.conf"
    )

    for file in "${candidates[@]}"; do
        [[ -f "$file" ]] && echo "$file" && return 0
    done

    return 1
}

postgres_data_dir_path() {
    local version="$1"
    local candidates=(
        "/var/lib/postgresql/${version}/main"
        "/var/lib/postgresql"
        "/var/lib/pgsql/${version}/data"
        "/var/lib/pgsql/data"
    )

    for dir in "${candidates[@]}"; do
        [[ -d "$dir" ]] && echo "$dir" && return 0
    done

    return 1
}

# Check if PostgreSQL service exists
postgres_service_exists() {
    if command_exists systemctl; then
        systemctl list-unit-files | grep -qE '^postgresql(@.*)?\.service' && return 0
    fi
    if command_exists service; then
        service --status-all 2>&1 | grep -qE 'postgresql' && return 0
    fi
    return 1
}

# Harden postgresql.conf
harden_postgres_conf() {
    log_section "Hardening PostgreSQL Main Configuration"

    local config="$1"

    if [[ ! -f "$config" ]]; then
        log_warn "PostgreSQL configuration file not found: $config"
        return 1
    fi

    backup_file "$config"

    # Read existing config and preserve comments
    local tmp
    tmp="$(mktemp)"

    # Keep all comment lines and empty lines
    grep -E '^\s*(#|$)' "$config" > "$tmp" || true

    # Extract non-comment, non-empty lines to check for existing settings
    local existing_settings
    existing_settings="$(mktemp)"
    grep -vE '^\s*(#|$)' "$config" > "$existing_settings" || true

    log_info "Writing hardened PostgreSQL configuration to $config"

    cat >> "$tmp" <<'EOF'

# === CyberPatriot PostgreSQL Hardening (auto) ===
# Generated by cp-engine postgres_hardening module

# ---------------------------
# CONNECTION SECURITY
# ---------------------------
EOF

    echo "listen_addresses = '${PG_LISTEN_ADDRESSES}'" >> "$tmp"
    echo "port = ${PG_PORT}" >> "$tmp"
    echo "max_connections = 100" >> "$tmp"
    echo "" >> "$tmp"

    cat >> "$tmp" <<'EOF'
# ---------------------------
# LOGGING AND AUDITING
# ---------------------------
EOF

    echo "log_connections = on" >> "$tmp"
    echo "log_disconnections = on" >> "$tmp"
    echo "log_duration = off" >> "$tmp"
    echo "log_line_prefix = '%m [%p] %q%u@%d '" >> "$tmp"
    echo "log_statement = 'ddl'" >> "$tmp"
    echo "log_lock_waits = on" >> "$tmp"
    echo "log_timezone = 'UTC'" >> "$tmp"
    echo "" >> "$tmp"

    cat >> "$tmp" <<'EOF'
# ---------------------------
# SSL/TLS CONFIGURATION
# ---------------------------
EOF

    echo "ssl = on" >> "$tmp"
    echo "ssl_cert_file = '${PG_SSL_CERT}'" >> "$tmp"
    echo "ssl_key_file = '${PG_SSL_KEY}'" >> "$tmp"
    echo "ssl_prefer_server_ciphers = on" >> "$tmp"
    echo "ssl_min_protocol_version = 'TLSv1.2'" >> "$tmp"
    echo "" >> "$tmp"

    cat >> "$tmp" <<'EOF'
# ---------------------------
# AUTHENTICATION
# ---------------------------
EOF

    echo "password_encryption = '${PG_AUTH_METHOD}'" >> "$tmp"
    echo "" >> "$tmp"

    cat >> "$tmp" <<'EOF'
# ---------------------------
# SECURITY PARAMETERS
# ---------------------------
EOF

    echo "shared_preload_libraries = ''" >> "$tmp"
    echo "fsync = on" >> "$tmp"
    echo "full_page_writes = on" >> "$tmp"
    echo "" >> "$tmp"

    # Apply configuration
    mv "$tmp" "$config"
    rm -f "$existing_settings"

    chmod 0644 "$config"
    chown postgres:postgres "$config" 2>/dev/null || chown postgres:postgres "$config"

    log_success "PostgreSQL main configuration hardened"
    log_score 3 "Hardened postgresql.conf with SSL, logging, and secure defaults"

    return 0
}

# Harden pg_hba.conf (Host-Based Authentication)
harden_pg_hba_conf() {
    log_section "Hardening PostgreSQL Host-Based Authentication (pg_hba.conf)"

    local config="$1"

    if [[ ! -f "$config" ]]; then
        log_warn "pg_hba.conf not found: $config"
        return 1
    fi

    backup_file "$config"

    local tmp
    tmp="$(mktemp)"

    log_info "Creating secure pg_hba.conf at $config"

    cat > "$tmp" <<EOF
# === CyberPatriot PostgreSQL pg_hba.conf Hardening (auto) ===
# PostgreSQL Client Authentication Configuration File
# Generated by cp-engine postgres_hardening module
#
# This file controls: which hosts are allowed to connect, how clients
# are authenticated, which PostgreSQL user names they can use, which
# databases they can access.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD

# ---------------------------
# LOCAL CONNECTIONS
# ---------------------------
# Local socket connections require password authentication (no peer/trust)
# This prevents system users from auto-logging in as postgres superuser
local   all             postgres                                ${PG_AUTH_METHOD}
local   all             all                                     ${PG_AUTH_METHOD}

# ---------------------------
# IPv4 LOCAL CONNECTIONS
# ---------------------------
# Localhost IPv4 connections require password authentication
host    all             all             127.0.0.1/32            ${PG_AUTH_METHOD}

# ---------------------------
# IPv6 LOCAL CONNECTIONS
# ---------------------------
# Localhost IPv6 connections require password authentication
host    all             all             ::1/128                 ${PG_AUTH_METHOD}

EOF

    # Add SSL-only remote connections if enabled
    if [[ "$PG_REQUIRE_SSL_REMOTE" == "yes" ]]; then
        cat >> "$tmp" <<EOF
# ---------------------------
# REMOTE CONNECTIONS (SSL ONLY)
# ---------------------------
# First, reject any non-SSL connection from any remote IP
hostnossl   all         all             0.0.0.0/0               reject

# Second, allow SSL connections with strong authentication
hostssl     all         all             0.0.0.0/0               ${PG_AUTH_METHOD}

EOF
        log_info "Configured pg_hba.conf to require SSL for all remote connections"
    else
        log_info "Remote SSL requirement disabled (PG_REQUIRE_SSL_REMOTE=no)"
    fi

    # Apply configuration
    mv "$tmp" "$config"

    chmod 0640 "$config"
    chown postgres:postgres "$config" 2>/dev/null || chown postgres:postgres "$config"

    log_success "pg_hba.conf hardened (no trust/peer methods, SSL required for remote)"
    log_score 3 "Hardened pg_hba.conf authentication rules"

    return 0
}

# Harden PostgreSQL file and directory permissions
harden_postgres_permissions() {
    log_section "Hardening PostgreSQL File Permissions"

    local data_dir="$1"

    if [[ ! -d "$data_dir" ]]; then
        log_warn "PostgreSQL data directory not found: $data_dir"
        return 0
    fi

    log_info "Securing PostgreSQL data directory: $data_dir"

    # Secure main data directory (rwx------)
    chown -R postgres:postgres "$data_dir" 2>/dev/null || true
    chmod 700 "$data_dir"
    log_debug "Set permissions 700 on $data_dir"

    # Secure all subdirectories
    find "$data_dir" -type d -exec chmod 700 {} \; 2>/dev/null || true
    log_debug "Set permissions 700 on all subdirectories in $data_dir"

    # Secure all regular files
    find "$data_dir" -type f -exec chmod 600 {} \; 2>/dev/null || true
    log_debug "Set permissions 600 on all files in $data_dir"

    log_success "PostgreSQL data directory permissions secured"
    log_score 2 "Secured PostgreSQL data directory permissions (700/600)"

    return 0
}

# Secure SSL private key
secure_ssl_keys() {
    log_section "Securing PostgreSQL SSL Keys"

    local ssl_key="$1"

    if [[ ! -f "$ssl_key" ]]; then
        log_warn "SSL private key not found: $ssl_key"
        log_info "You may need to generate SSL certificates for PostgreSQL"
        return 0
    fi

    log_info "Securing SSL private key: $ssl_key"

    # SSL private key must be readable only by postgres user
    chown postgres:postgres "$ssl_key" 2>/dev/null || true
    chmod 600 "$ssl_key"

    # Also secure the certificate if it exists in the same directory
    local ssl_cert="${ssl_key%.key}.crt"
    if [[ ! -f "$ssl_cert" ]]; then
        ssl_cert="${PG_SSL_CERT}"
    fi

    if [[ -f "$ssl_cert" ]]; then
        chmod 644 "$ssl_cert"
        log_debug "Set permissions 644 on SSL certificate: $ssl_cert"
    fi

    log_success "SSL private key secured (600, owned by postgres)"
    log_score 1 "Secured PostgreSQL SSL private key"

    return 0
}

# Verify PostgreSQL is not running as root
verify_postgres_user() {
    log_section "Verifying PostgreSQL Process User"

    # Check if postgres is running
    if ! pgrep -x postgres >/dev/null 2>&1; then
        log_info "PostgreSQL is not currently running, skipping process check"
        return 0
    fi

    # Check what user postgres is running as
    local postgres_user
    postgres_user=$(ps aux | grep -E '[p]ostgres.*main' | awk '{print $1}' | head -n1 || true)

    if [[ -z "$postgres_user" ]]; then
        # Try alternative method
        postgres_user=$(pgrep -x postgres -u postgres >/dev/null 2>&1 && echo "postgres" || echo "unknown")
    fi

    if [[ "$postgres_user" == "root" ]]; then
        log_error "CRITICAL: PostgreSQL is running as root user!"
        log_error "This is a severe security vulnerability."
        log_error "PostgreSQL should run as the 'postgres' unprivileged user."
        return 1
    elif [[ "$postgres_user" == "postgres" ]]; then
        log_success "PostgreSQL is running as unprivileged user 'postgres'"
        log_score 1 "PostgreSQL running as non-root user"
    else
        log_warn "PostgreSQL appears to be running as: $postgres_user"
    fi

    return 0
}

# Reload PostgreSQL service
postgres_service_reload() {
    log_section "Reloading PostgreSQL Service"

    if ! command_exists systemctl; then
        log_warn "systemctl not found, skipping service reload"
        return 0
    fi

    # Try to find the postgresql service
    local service_name=""

    if systemctl list-unit-files | grep -q '^postgresql\.service'; then
        service_name="postgresql"
    elif systemctl list-unit-files | grep -qE '^postgresql@.*\.service'; then
        # Handle version-specific services (e.g., postgresql@15-main.service)
        service_name=$(systemctl list-unit-files | grep -E '^postgresql@.*\.service' | head -n1 | awk '{print $1}')
    fi

    if [[ -z "$service_name" ]]; then
        log_warn "PostgreSQL service not found in systemd, skipping reload"
        return 0
    fi

    # Check if service is active before reloading
    if ! systemctl is-active "$service_name" >/dev/null 2>&1; then
        log_info "PostgreSQL service is not running, skipping reload"
        return 0
    fi

    log_info "Reloading PostgreSQL configuration (service: $service_name)"

    if systemctl reload "$service_name" >/dev/null 2>&1; then
        log_success "PostgreSQL service reloaded successfully"
    else
        log_warn "Failed to reload PostgreSQL service, attempting restart..."
        if systemctl restart "$service_name" >/dev/null 2>&1; then
            log_success "PostgreSQL service restarted successfully"
        else
            log_error "Failed to restart PostgreSQL service"
            return 1
        fi
    fi

    return 0
}

# Validate PostgreSQL configuration
validate_postgres_config() {
    log_section "Validating PostgreSQL Configuration"

    # Check if pg_isready is available
    if command_exists pg_isready; then
        log_info "Testing PostgreSQL connectivity with pg_isready"

        if pg_isready -h localhost -p "${PG_PORT}" >/dev/null 2>&1; then
            log_success "PostgreSQL is accepting connections on port ${PG_PORT}"
        else
            log_warn "PostgreSQL is not responding (may not be running)"
            log_info "This is not necessarily an error if the service is stopped"
        fi
    else
        log_info "pg_isready not available, skipping connectivity test"
    fi

    return 0
}

# Display summary
display_summary() {
    log_section "PostgreSQL Hardening Summary"

    log_success "PostgreSQL hardening completed successfully"
    log_info "Security improvements applied:"
    log_info "  - listen_addresses: ${PG_LISTEN_ADDRESSES}"
    log_info "  - port: ${PG_PORT}"
    log_info "  - SSL: enabled (TLS 1.2+)"
    log_info "  - Connection logging: enabled"
    log_info "  - DDL statement logging: enabled"
    log_info "  - Password encryption: ${PG_AUTH_METHOD}"
    log_info "  - Authentication: no trust/peer methods"

    if [[ "$PG_REQUIRE_SSL_REMOTE" == "yes" ]]; then
        log_info "  - Remote connections: SSL required"
    else
        log_info "  - Remote connections: SSL not required"
    fi

    log_info "  - Data directory: secured (700 permissions)"
    log_info "  - SSL private key: secured (600 permissions)"

    log_info ""
    log_info "IMPORTANT: PostgreSQL superuser (postgres) now requires password authentication."
    log_info "Set a strong password if not already set:"
    log_info "  sudo -u postgres psql -c \"ALTER USER postgres PASSWORD 'STRONG_PASSWORD_HERE';\""

    return 0
}

# Main module function
run_postgres_hardening() {
    log_info "Starting PostgreSQL Hardening module..."

    # Check if PostgreSQL service exists
    if ! postgres_service_exists; then
        log_warn "PostgreSQL service not found on this system, skipping module"
        return 0
    fi

    require_root

    # Detect PostgreSQL version
    local pg_version
    pg_version=$(detect_postgres_version)

    if [[ -z "$pg_version" ]]; then
        log_warn "Could not detect PostgreSQL version, attempting to find configs anyway"
        pg_version=""
    else
        log_info "Detected PostgreSQL version: $pg_version"
    fi

    # Find configuration files
    local config_file hba_file data_dir

    config_file=$(postgres_config_path "$pg_version")
    if [[ -z "$config_file" ]]; then
        log_warn "PostgreSQL configuration file (postgresql.conf) not found"
        return 0
    fi
    log_info "Found postgresql.conf: $config_file"

    hba_file=$(pg_hba_config_path "$pg_version")
    if [[ -z "$hba_file" ]]; then
        log_warn "PostgreSQL HBA file (pg_hba.conf) not found"
        return 0
    fi
    log_info "Found pg_hba.conf: $hba_file"

    data_dir=$(postgres_data_dir_path "$pg_version")
    if [[ -z "$data_dir" ]]; then
        log_warn "PostgreSQL data directory not found"
    else
        log_info "Found data directory: $data_dir"
    fi

    # Execute hardening steps
    harden_postgres_conf "$config_file" || return 1
    harden_pg_hba_conf "$hba_file" || return 1

    if [[ -n "$data_dir" ]]; then
        harden_postgres_permissions "$data_dir"
    fi

    secure_ssl_keys "$PG_SSL_KEY"
    verify_postgres_user

    # Reload PostgreSQL service to apply changes
    postgres_service_reload

    # Validate configuration
    validate_postgres_config

    # Display summary
    display_summary

    log_success "PostgreSQL Hardening module completed"
    return 0
}

export -f run_postgres_hardening
